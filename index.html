<!DOCTYPE html>
<html>
    <head>
        <title>dcpos.ch webgl test</title>
        <style>
            body{
                font-family: helvetica, sans-serif;
                padding:40px;
                margin:0;
                background: #888;
            }
            h1{
                font-size:24px;
            }
            canvas#gl {
                width:100%;
                height:70%;
                max-width:1920;
                max-height:1080;

                cursor:none;
            }
        </style>
    </head>

<body>
    <h1>dcpos.ch webgl test</h1>    
    <canvas id="gl" ></canvas>
    <h2 id="status">initializing...</h2>



<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.js"></script>
<script type="text/javascript" src="glMatrix.js"></script>
<script type="text/javascript">
$.get("dcshaders.html", function(html){
    $("body").append(html);
    main();
});
</script>
<script type="text/javascript" src="dcgl.js"></script>
<script type="text/javascript" src="dcinput.js"></script>

<script type="text/javascript">
function genSquare(){
    var verts = [
        1,0,0,
        1,1,0,
        0,1,0,
        0,0,0,
        2,2,3];
    var cols = [
        1,1,1,
        1,1,1,
        1,1,1,
        1,1,1,
        1,1,1];
    var norms = [
        1,1,1,
        1,1,1,
        1,1,1,
        1,1,1,
        1,1,1];
    var tris = [
        0, 1, 2,
        0, 2, 3,
        0, 4, 2,
            ];

    var model = {
        ntris:tris.length/3,
        nverts:verts.length/3,

        positions:new Float32Array(verts),
        colors:new Float32Array(cols),
        normals:new Float32Array(norms),
        tris:new Uint32Array(tris),
        position:vec3.create()
    };
    return model;
}


function genTerrain(){
    var tris = [], cols = [], norms = [];
    var heights = [], normals = [];
    var w = 20, h = 20;
    for(var i = 0; i < w; i++){
        for(var j = 0; j < h; j++){
            var x = i - 10;
            var y = Math.sin(i*j/30)/0.5;
            heights[i*h+j] = y;
            var di = Math.cos(i*j/30)/0.5*j/30;
            var dj = Math.cos(i*j/30)/0.5*i/30;
            var normal = vec3.normalize(vec3.create([dj,-1,di]));
            normals[i*h+j] =[normal[0], normal[1], normal[2]];
            var z = j - 10;
            if(i > 0 && j > 0){
                tris.push(x,   heights[i*h+j],       z);
                tris.push(x-1, heights[(i-1)*h+j-1], z-1);
                tris.push(x,   heights[i*h+j-1],     z-1);
                tris.push(x-1, heights[(i-1)*h+j-1], z-1);
                tris.push(x,   heights[i*h+j],       z);
                tris.push(x-1, heights[(i-1)*h+j],   z);

                cols.push(0.7,   0,   0);
                cols.push(0.7,   0,   0);
                cols.push(0.7,   0,   0);
                cols.push(0.7,   0,   0);
                cols.push(0.7,   0,   0);
                cols.push(0.7,   0,   0);

                norms.push.apply(norms, normals[i*h+j]);
                norms.push.apply(norms, normals[(i-1)*h+j]);
                norms.push.apply(norms, normals[i*h+j-1]);
                norms.push.apply(norms, normals[(i-1)*h+j-1]);
                norms.push.apply(norms, normals[i*h+j]);
                norms.push.apply(norms, normals[(i-1)*h+j]);
            }
        }
    }
    var model = {
        nverts: tris.length/3,

        positions:new Float32Array(tris),
        colors:new Float32Array(cols),
        normals:new Float32Array(norms)
    };
    return model;
}

function genTerrain2(){
    var verts = [], cols = [], norms = [], tris = [];
    var heights = [];
    var w = 20, h = 20;
    for(var i = 0; i < w; i++){
        for(var j = 0; j < h; j++){
            var x = i - 10;
            var y = Math.sin(i*j/30)/0.5;
            heights[i*h+j] = y;
            var z = j - 10;
            if(i > 0 && j > 0){
                var ix = verts.length;

                verts.push(x,   heights[i*h+j],       z);
                verts.push(x-1, heights[(i-1)*h+j-1], z-1);
                verts.push(x,   heights[i*h+j-1],     z-1);
                verts.push(x-1, heights[(i-1)*h+j],   z);

                cols.push(1,   1,   0);
                cols.push(1,   0,   1);
                cols.push(0,   1,   1);
                cols.push(0,   1,   0);

                norms.push(1,   0,   0);
                norms.push(0,   1,   0);
                norms.push(0,   0,   1);
                norms.push(0,   1,   0);

                tris.push(ix);
                tris.push(ix+1);
                tris.push(ix+2);
                tris.push(ix+2);
                tris.push(ix+1);
                tris.push(ix+3);
            }
        }
    }

    var model = {
        ntris:tris.length/3,
        nverts:verts.length/3,

        positions:new Float32Array(verts),
        colors:new Float32Array(cols),
        normals:new Float32Array(norms),
        tris:new Uint32Array(tris),
        position:vec3.create()
    };
    return model;
}


function genGlobe(){
    var radius = 20;
    var verts = [], cols = [], norms = [];
    var lats = 100;
    var maxlons = 100;
    for(var i = 0; i < lats; i++){
        var lat = (((i+0.5)/lats)*2-1)*Math.PI/2;
        var lons = Math.cos(lat)*maxlons;
        for(var j = 0; j < lons; j++){
            var lon = (j/lons)*Math.PI*2;

            var x = Math.cos(lon)*Math.cos(lat);
            var y = Math.sin(lat);
            var z = Math.sin(lon)*Math.cos(lat);

            verts.push(x*radius, y*radius, z*radius);
            cols.push(Math.sin(lon)*.5+.5,Math.cos(lon)*.5+.5,Math.sin(lon+1)*.5+.5);
            norms.push(x,y,z);
        }
    }
    var model = {
        type:'pointcloud',
        positions:new Float32Array(verts),
        colors:new Float32Array(cols),
        normals:new Float32Array(norms)
    };
    return model;
}

function genGrid(){
    var gridWidth = 10000;
    var y = -2;
    var verts = [
        -gridWidth/2, y, gridWidth/2,
        -gridWidth/2, y,-gridWidth/2,
         gridWidth/2, y, gridWidth/2,
         gridWidth/2, y,-gridWidth/2];
    var norms = [
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
        0, 1, 0];
    var uvs = [
        0,1,
        0,0,
        1,1,
        1,0
        ];
    var tris = [
        0, 1, 2,
        1, 2, 3];
    var model = {
        ntris:tris.length/3,
        nverts:verts.length/3,

        positions:new Float32Array(verts),
        uvs:new Float32Array(uvs),
        normals:new Float32Array(norms),
        tris:new Uint32Array(tris),
        position:vec3.create(),

        vertex_shader: "vert_texture",
        fragment_shader: "frag_grid",

        prerender: function(mod) {
            var pos = car.position;
            var uuv = [(pos[0] + gridWidth/2) / gridWidth, 
               (pos[2] + gridWidth/2) / gridWidth];
            var uvPos = gl.getUniformLocation(prog, "uUv");
            gl.uniform2f(uvPos,uuv[0],uuv[1]);
        }
    };
    return model;
}

function genCar(){
    var verts = [
        -3,-3,-3,
        -3,-3, 3,
        -3, 3,-3,
        -3, 3, 3,
         2,-2,-2,
         2,-2, 2,
         2, 2,-2,
         2, 2, 2];
    var cols = [
        0,0.5,0,
        0,0.5,0,
        0,0.5,0,
        0,0.5,0,
        0,0.7,0,
        0,0.7,0,
        0,0.7,0,
        0,0.7,0];
    var norms = [
        1,1,1,
        1,1,1,
        1,1,1,
        1,1,1,
        1,1,1,
        1,1,1,
        1,1,1,
        1,1,1];
    var tris = [
        0, 1, 2,
        1, 2, 3,
        4, 5, 6,
        5, 6, 7,
        0, 1, 4,
        1, 4, 5,
        2, 3, 6,
        3, 6, 7,
        0, 2, 4,
        2, 4, 6,
        1, 3, 5,
        3, 5, 7
            ];

    var model = {
        ntris:tris.length/3,
        nverts:verts.length/3,

        positions:new Float32Array(verts),
        colors:new Float32Array(cols),
        normals:new Float32Array(norms),
        tris:new Uint32Array(tris),
        position:vec3.create(),

        speed:0,
        heading:0
    };
    return model;
}

</script>

<script type="text/javascript">

// dom
var canvas = $("#gl");

// world
var scene;
var car;

var gas_accel = 0.1;
var brake_accel = 0.1;
var reverse_accel = 0.03;
var max_accel = 0.2;
var max_reverse = 1;
var accel = function(speed){ return max_accel*(1 - speed*speed/25); }
var turn_rads = 0.05;


function drawScene() {

    //scale, clear window
    var width = canvas.width();
    var height = canvas.height();
    canvas[0].width = width;
    canvas[0].height = height;
    gl.viewport(0, 0, width, height); 
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    //setup camera
    mat4.perspective(45, width / height, 0.1, 10000.0, pmat);

    //setup matrixes
    mat4.identity(mvmat);
    mat4.rotate(mvmat, -azith, [1,0,0]);
    mat4.rotate(mvmat, -dir, [0,1,0]);
    mat4.translate(mvmat, [-loc[0], -loc[1], -loc[2]]);

    //render
    for(var i = 0; i < scene.length; i++){
        var model = scene[i];

        //load material (shaders)
        if(model.vertex_shader && model.fragment_shader){
            setShaders(model.vertex_shader, model.fragment_shader);
        } else {
            setShaders("vert_simple", "frag_color");
        }
        //load model data
        setAttributes(model);

        //transform, render
        mvpush();
        mat4.translate(mvmat, vec3.create(model.position));
        if(model.heading)
            mat4.rotate(mvmat, -model.heading, [0,1,0]);
        setUniforms();


        //allow model to do fancy stuff
        if(model.prerender)
            model.prerender();

        if(model.tris){
            //draw element array (array contains vertex indices)
            var buf = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf);
            var tris = new Uint16Array(model.tris);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, tris, gl.STATIC_DRAW);
            gl.drawElements(gl.TRIANGLES, tris.length, gl.UNSIGNED_SHORT, 0);
        } else {
            //draw triangle array
            gl.drawArrays(gl.TRIANGLES, 0, model.nverts);
        }

        if(model.postrender)
            model.postrender();

        mvpop();
    }
}

function init(canvas) {
    //make a simple scene
    scene = [];
    car = genCar();
    scene.push(car);
    scene.push(genGrid());

    initGL(canvas);
}

function update(){

    //keyboard
    var step_move = 2;
    var step_turn = 0.03;
    var vforward = vec3.create(
        [-Math.sin(dir),0,-Math.cos(dir)]);
    var vright = vec3.create(
        [Math.cos(dir),0,-Math.sin(dir)]);
    vec3.scale(vforward, step_move);
    vec3.scale(vright, step_move);
     
    if(keys["up"]){
        car.speed += accel(car.speed);
    }
    if(keys["down"]){
        if(car.speed > 0)
            car.speed -= brake_accel;
        else
            car.speed -= reverse_accel;
        if(car.speed < -max_reverse)
            car.speed = -max_reverse;
    }
    if(keys["left"]){
        car.heading += turn_rads;
    }
    if(keys["right"]){
        car.heading -= turn_rads;
    }

    //mouse
    var sensitivity_x = 0.01;
    var sensitivity_y = 0.01;
    var min_azith = -Math.PI/4;
    var max_azith = Math.PI/4;
    if(mouse.drag){
        dir += mouse.move.x*sensitivity_x;
        azith += mouse.move.y*sensitivity_y;
        azith = Math.max(min_azith, Math.min(max_azith, azith));
        mouse.move = {x:0, y:0};
    }

    //status
    var model = scene[0];
    $("#status").text(model.positions.length + " vertices, " + (model.positions.length*3*3*4/1000) + " KB model mem"
            + ", loc ("+loc[0]+","+loc[1]+","+loc[2]+")");

    physics();
    cameraTracking();
}

function physics(){
    car.direction = vec3.create([Math.cos(car.heading), 0, Math.sin(car.heading)]);
    var dpos = vec3.create(car.direction);
    vec3.scale(dpos, car.speed);
    vec3.add(car.position, dpos);
}

var count = 0;
function cameraTracking(){
    // decay toward a place behind the car
    var target = vec3.create();
    var dpos = vec3.create(car.direction);
    vec3.scale(dpos, -30.0);
    vec3.add(car.position, dpos, target);
    target[1] = 5;

    vec3.subtract(target,loc);
    vec3.scale(target, 0.1);
    vec3.add(loc,target);

    // always look at the car
    vec3.subtract(car.position, loc, target);

    if(!mouse.drag){
        var decay = 0.8;
        var newDir = Math.atan2(-target[0], -target[2]);
        while(dir < newDir-Math.PI)
            dir += 2*Math.PI;
        while(dir > newDir+Math.PI)
            dir -= 2*Math.PI;
        dir = decay*dir + (1-decay)*newDir;
        azith = decay*azith;
    }
}

function frame(){
    update();
    drawScene();
}

function main(){
    var canvas = $("#gl")[0];
    init(canvas);
    animate(frame, canvas);
}

</script>
</body>

</html>
